package main

/* Build line boxes from text prediction and box files generated by
 * tesseract
 * Config file:
 *   tessedit_create_txt 1 
 *   tessedit_create_boxfile 1
 *
 * Input: img.png predict.box predict.txt
 * Output: predict-preview.png
 *         predict-lines.json
 *         predict-paragraphs.json
 *         predict/t-###.txt
 *         predict/l-###.png
 */

import (
  "bufio"
  "encoding/json"
  "errors"
  "flag"
  "fmt"
  _ "io/ioutil"
  "image"
  "image/color"
  "image/draw"
  "image/png"
  "log"
  "os"
  "path"
  _ "regexp"
  "sort"
  "strconv"
  "strings"
)

type Params struct {
  ImgFileName string
  BaseFileName string
  CutLines bool
}

type Quartiles struct {
  min int
  q1  int
  med int
  q3  int
  max int
}

type Point struct {
  x int
  y int
}

type Points []Point

type Box struct {
  glyph string
  x0 int
  y0 int
  x1 int
  y1 int
}

type Boxes []Box

type BoxLine struct {
  boxes Boxes
}

type JsBoxes struct {
  Boxes [][]int
}

type JsParas struct {
  Paragraphs []bool
}

type stringlist_t []string
type wordcount_t struct {
  word string
  count int
}

type summary_t struct {
  replacements map[string]wordcount_t
}

const (
  LINE_BORDER = 20 // maximal space above below linebox relative to its height
)

var summary summary_t

func str2map(s string) map[rune]bool {
  res := map[rune]bool{}
  for _, r := range(s) {
    res[r] = true
  }
  return res
}

func (q Quartiles) String() string {
  return fmt.Sprintf("min: %d q1: %d med: %d q3: %d max: %d",
    q.min, q.q1, q.med, q.q3, q.max)
}

const UsageText = `Split png image into lines according to text and box tessact prediction
Usage: %s options

Output: <base>-preview.png
        <base>-lines.json         line boxes
        <base>-paragraphs.json    paragraphs
        <base>/l-###.png          line images
`

func readParams() *Params {
  flag.Usage = func() {
    fmt.Fprintf(os.Stderr, UsageText, os.Args[0])
    flag.PrintDefaults()
  }
  params := &Params{}
  flag.StringVar(&params.ImgFileName, "image", "",
    "Image file name")
  flag.StringVar(&params.ImgFileName, "i", "",
    "Image file name (short)")
  flag.StringVar(&params.BaseFileName, "basename", "",
    "Base file name of text and box file")
  flag.StringVar(&params.BaseFileName, "b", "",
    "Base file name of text and box file (short)")
  flag.BoolVar(&params.CutLines, "cutlines", false,
    "Cut lines with glyph boxes")
  flag.BoolVar(&params.CutLines, "c", false,
    "Cut lines with glyph boxes (short)")
  flag.Parse()
  if params.ImgFileName == "" {
    flag.Usage()
    log.Fatal("Image file missing")
  }
  if params.BaseFileName == "" {
    flag.Usage()
    log.Fatal("Base file name missing")
  }
  return params
}

func (box *Box) isEmpty() bool {
  return box.y1-box.y0 == 0
}

func (boxLine *BoxLine) isEmpty() bool {
  for _, box := range(boxLine.boxes) {
    if !box.isEmpty() { return false }
  }
  return true
}

func nonEmptyBoxes(boxes []Box) []Box {
  res := []Box{}
  for _, b := range boxes {
    if !b.isEmpty() {
      res = append(res, b)
    }
  }
  return res;
}

func removeEmptyBoxLines(boxLines []BoxLine) []BoxLine {
  res := []BoxLine{}
  for _, line := range(boxLines) {
    if line.isEmpty() { continue }
    log.Println("removeEmpty preserve", line)
    res = append(res, line)
  }
  return res;
}

func intQuartiles (vals []int) Quartiles {
  if len(vals) == 0 {
    return Quartiles{-1, -1, -1, -1, -1}
  }
  sort.Ints(vals)
  l := len(vals)-1
  return Quartiles{vals[0], vals[l/4], vals[l/2], vals[3*l/4], vals[l]}
}

func (boxes Boxes) boundingBox() Box {
  if len(boxes) == 0 {
    return Box{"", 0, 0, 0, 0}
  }
  res := boxes[0]
  for _, b := range boxes[1:len(boxes)] {
    res.glyph += b.glyph
    if b.isEmpty() { continue }
    if b.x0 < res.x0 { res.x0 = b.x0 }
    if b.y0 < res.y0 { res.y0 = b.y0 }
    if b.x1 > res.x1 { res.x1 = b.x1 }
    if b.y1 > res.y1 { res.y1 = b.y1 }
  }
  return res
}

func (points Points) boundingBox() Box {
  if len(points) == 0 {
    return Box{"", 0, 0, 0, 0}
  }
  res := Box{"", points[0].x, points[0].y, points[0].x, points[0].y}
  for _, p := range points[1:] {
    if p.x < res.x0 { res.x0 = p.x }
    if p.y < res.y0 { res.y0 = p.y }
    if p.x > res.x1 { res.x1 = p.x }
    if p.y > res.y1 { res.y1 = p.y }
  }
  return res
}

func readBoxes(txtFile, boxFile string) ([]string, []Box) {
  ftxt, err2 := os.Open(txtFile)
  txt := []string{}
  if err2 != nil {
    log.Println(err2)
    return txt, nil
  }
  defer ftxt.Close()
  txtScanner := bufio.NewScanner(ftxt)
  for txtScanner.Scan() {
    txt = append(txt, txtScanner.Text())
  }
  if _, err := os.Stat(boxFile); os.IsNotExist(err) {
    log.Println("No box file", boxFile)
    return txt, nil
  }
  fbox, err := os.Open(boxFile)
  if err != nil {
    fmt.Println(err)
    return txt, nil
  }
  defer fbox.Close()
  boxScanner := bufio.NewScanner(fbox)
  boxes := []Box{}
  for boxScanner.Scan() {
    parts := strings.Split(boxScanner.Text(), " ")
    glyph := parts[0]
    pos := make([]int, 4)
    for i, p := range(parts[1:5]) {
      pos[i], err = strconv.Atoi(p)
    }
    boxes = append(boxes, Box{glyph, pos[0], pos[1], pos[2], pos[3]})
  }
  return txt, boxes
}

func matchBoxes(boxes []Box, lines []string) []Box {
  res := []Box{}
  part := strings.Join(lines, "\n")
  for _, box := range(boxes) {
    i := strings.Index(part, box.glyph)
    if i < 0 {
      log.Printf("Glyph %s not in string\n", box.glyph)
      continue
    } else if i > 0 {
      for _, r := range(part[:i]) {
        res = append(res, Box{string(r), 0, 0, 0, 0})
      }
      if part[:i] != " " {
        log.Printf("No Box for %q\n", part[:i])
      }
    }
    res = append(res, box)
    part = part[i+len(box.glyph):]
  }
  if part != "" {
    for _, r := range(part) {
      res = append(res, Box{string(r), -1, -1, -1, -1})
    }
    log.Printf("No Box for %q\n", part)
  }
  return res
}

func boxes2text(boxes []Box) string {
  res := []string{}
  for _, box := range(boxes) {
    res = append(res, box.glyph)
  }
  return strings.Join(res, "")
}

func newBoxLine(boxes []Box) BoxLine {
  res := BoxLine{
    boxes: boxes,
  }
  return res
}

func boxes2lines(boxes []Box) []BoxLine {
  res := []BoxLine{}
  startIdx := 0
  for i, box := range(boxes) {
    if box.glyph == "\n" {
      res = append(res, newBoxLine(boxes[startIdx:i]))
      startIdx = i+1
    }
  }
  if startIdx < len(boxes)-1 {
    res = append(res, newBoxLine(boxes[startIdx:]))
  }
  for _, boxes := range(res) {
    log.Println(boxes2text(boxes.boxes))
  }
  return res
}

func medStartPos(boxLines []BoxLine) (Quartiles, error) {
  starts := []int{}
  for _, boxLine := range(boxLines) {
    x0 := -1
    for _, box := range(boxLine.boxes) {
      if box.x0 >= 0 {
        x0 = box.x0
        break
      }
    }
    if x0 >= 0 {
      starts = append(starts, x0)
    }
    //log.Printf("%d %q\n", x0, boxes2text(boxLine.boxes))
  }
  if len(starts) == 0 {
    return Quartiles{-1, -1, -1, -1, -1}, errors.New("empty")
  }
  return intQuartiles(starts), nil
}

func processBoxes(lines []string, boxes []Box) []BoxLine {
  boxes = matchBoxes(boxes, lines)
  text := strings.Join(lines, "\n")
  boxText := boxes2text(boxes)
  if text != boxText {
    log.Println("different text and box prediction: ")
    log.Println("text:", text)
    log.Println("box: ", boxText)
  }
  return boxes2lines(boxes)
}

func boundingBoxes(boxLines []BoxLine) []Box {
  res := []Box{}
  for _, boxLine := range(boxLines) {
    bbox := boxLine.boxes.boundingBox()
    res = append(res, bbox)
  }
  return res
}

func buildJson(boxes []Box, imgBounds image.Rectangle) (JsBoxes, JsParas) {
  var resBoxes JsBoxes
  var resParas JsParas

  xx0 := imgBounds.Min.X
  yy1 := imgBounds.Max.Y
  isPara := false
  for _, box := range boxes {
    //fmt.Printf("x0: %d xx0: %d\n", box.x0, xx0)
    if box.isEmpty() {
      isPara = true
    } else {
      line := []int{box.x0-xx0, yy1-box.y1, box.x1-xx0, yy1-box.y0}
      resBoxes.Boxes = append(resBoxes.Boxes, line)
      resParas.Paragraphs = append(resParas.Paragraphs, isPara)
      isPara = false
    }
  }
  return resBoxes, resParas
}

func writeJson(lineBoxFile, paraFile string, lineboxes []Box, m image.Image) {
  jsBoxes, jsParas := buildJson(lineboxes, m.Bounds())
  if b, err := json.Marshal(jsBoxes); err != nil {
    log.Fatal(err)
  } else {
    fo, err := os.Create(lineBoxFile)
    if err != nil {
      log.Fatal(err)
    }
    fo.Write(b)
    fo.Close()
  }
  if b, err := json.Marshal(jsParas); err != nil {
    log.Fatal(err)
  } else {
    fo, err := os.Create(paraFile)
    if err != nil {
      log.Fatal(err)
    }
    fo.Write(b)
    fo.Close()
  }
}

func splitText(base string, lineboxes []Box) {
  i := 0
  for _, box := range lineboxes {
    if box.isEmpty() { continue }
    fileName := path.Join(base, fmt.Sprintf("t-%03d.txt", i))
    if fo, err := os.Create(fileName); err != nil {
      log.Println(err, fileName)
    } else {
      fo.WriteString(box.glyph)
      fo.Close()
    }
    i++
  }
}

func drawH(mm *image.Gray, x0, x1, y int) {
  for x := x0; x <= x1; x++ {
    mm.SetGray(x, y, color.Gray{0})
  }
}

func drawV(mm *image.Gray, x, y0, y1 int) {
  if y0 > y1 { y0, y1 = y1, y0 }
  for y := y0; y <= y1; y++ {
    mm.SetGray(x, y, color.Gray{0})
  }
}

func cutImage(img *image.Gray, box Box, lineBoxes []Box) {
  white := color.Gray{255}
  fullBoxes := nonEmptyBoxes(lineBoxes)
  for k, b := range fullBoxes {
    x0 := b.x0-box.x0
    if k > 0 {
      x0 = fullBoxes[k-1].x1 - box.x0 + 1
    }
    x1 := b.x1 - box.x0
    if k < len(fullBoxes) -1 {
      x1 = fullBoxes[k+1].x0 -box.x0 - 1
    }
    y0 := 0
    y1 := box.y1 - b.y1 - 1
    draw.Draw(img,
      image.Rect(x0, y0, x1, y1),
      &image.Uniform{white}, image.Point{0,0}, draw.Src)
    y0 = box.y1 - b.y0 + 1
    y1 = box.y1 - box.y0
    draw.Draw(img,
      image.Rectangle{image.Point{x0, y0}, image.Point{x1, y1}},
      &image.Uniform{white}, image.ZP, draw.Src)
  }
}

func drawCutLines(mm *image.Gray, xx0, yy1 int, cutLines []Points) {
  for _, line := range(cutLines) {
    pPrev := line[0]
    for _, p := range(line[1:]) {
      if pPrev.x == p.x {
        drawV(mm, p.x + xx0, yy1 - pPrev.y, yy1 - p.y)
      } else {
        drawH(mm, pPrev.x + xx0, p.x + xx0, yy1 - p.y)
      }
      pPrev = p
    }
  }
}

func findMeanLine(bottom Points, top Points) Points {
  midLine := Points{}
  iTop := 0
  iBottom := 0
  //log.Println(bottom)
  //log.Println(top)
  // find start point
  for iBottom < len(bottom)-2 && bottom[iBottom+2].x < top[0].x {
    iBottom += 2;
  }
  for iTop < len(top)-2 && top[iTop+2].x < bottom[0].x {
    iTop += 2;
  }
  yBottom := bottom[iBottom].y
  yTop := top[iTop].y
  yMean := (yTop + yBottom) / 2
  isStart := true
  for iTop < len(top) && iBottom < len(bottom) {
    x := top[iTop].x
    if top[iTop].x < bottom[iBottom].x {
      yTop = top[iTop].y
      iTop += 2
    } else {
      x = bottom[iBottom].x
      yBottom = bottom[iBottom].y
      iBottom += 2
    }
    //log.Printf("midline x %d itop %d ibottom %d yold %d",
    //  x, iTop, iBottom, yMean)
    // old y
    if isStart {
      isStart = false
    } else {
      midLine = append(midLine, Point{x, yMean})
    }
    yMean = (yTop + yBottom) / 2
    //log.Printf(" ynew %d\n", yMean)
    // new y
    midLine = append(midLine, Point{x, yMean})
  }
  iTop = len(top) - 1
  iBottom = len(bottom) - 1
  x := top[iTop].x
  if bottom[iBottom].x < x {
    x = bottom[iBottom].x
  }
  midLine = append(midLine, Point{x, yMean})

  //log.Println("cutline", midLine)
  return midLine
}

func getCutLines(lineBoxes []BoxLine) []Points {
  res := []Points{}
  prevBottom := Points{}
  for iLine, boxLine := range(lineBoxes) {
    lineTop := Points{}
    lineBottom := Points{}
    //log.Println("getCutLines", iLine, boxLine.boxes)
    prevBox := Box{}
    start := true
    for _, box := range(boxLine.boxes) {
      if box.isEmpty() { continue }
      if  start {
        lineTop = append(lineTop, Point{box.x0, box.y1})
        lineBottom = append(lineBottom, Point{box.x0, box.y0})
        start = false
      } else {
        x := box.x0 // extend prev box to next glyph
        // if current glyph is smaller than prev, extend its box to prev.
        if prevBox.y1 > box.y1 { x = prevBox.x1 }
        lineTop = append(lineTop, Point{x, prevBox.y1})
        lineTop = append(lineTop, Point{x, box.y1})
        x = box.x0 // same for bottom line
        if prevBox.y0 < box.y0 { x = prevBox.x1 }
        lineBottom = append(lineBottom, Point{x, prevBox.y0})
        lineBottom = append(lineBottom, Point{x, box.y0})
      }
      prevBox = box
    }
    lineTop = append(lineTop, Point{prevBox.x1, prevBox.y1})
    lineBottom = append(lineBottom, Point{prevBox.x1, prevBox.y0})
    if iLine > 0 {
      // find middle line
      midLine := findMeanLine(prevBottom, lineTop)
      res = append(res, midLine)
      // debug
      //res = append(res, lineTop)
      //res = append(res, prevBottom)
      //log.Println("top", len(lineTop), "bottom", len(prevBottom),
      //  "mid", len(midLine))
      //log.Println("midLine", midLine, boxes2text(boxLine.boxes))
    }
    prevBottom = lineBottom
  }
  return res
}

func splitImageBboxes(workDir string, lineBoxes []BoxLine, lineBboxes []Box,
    m image.Image) {
  xx0 := m.Bounds().Min.X
  yy1 := m.Bounds().Max.Y
  mm := m.(*image.Gray)
  i := 0
  for j, box := range lineBboxes {
    if box.isEmpty() { continue }
    subImg := image.NewGray(image.Rect(
      0, 0, box.x1-box.x0, box.y1-box.y0),
    )
    draw.Draw(subImg, subImg.Bounds(), mm, image.Point{box.x0+xx0, yy1-box.y1},
      draw.Src)
    jp := j-1
    for jp >= 0 && lineBboxes[jp].isEmpty() { jp-- }
    if jp >= 0 && yy1-lineBboxes[jp].y1 > yy1-box.y0 {
      log.Printf("Upper overlapping line %d y1-prev %d y0 %d\n", j,
        yy1-lineBboxes[jp].y1, yy1-box.y0)
      // TODO clean up
    }
    jn := j+1
    for jn < len(lineBboxes) && lineBboxes[jn].isEmpty() { jn++ }
    if jn < len(lineBboxes) && yy1-lineBboxes[jn].y0 < yy1-box.y1 {
      log.Printf("Lower overlapping line %d y1 %d y0-succ %d\n", j,
        yy1-box.y1, yy1-lineBboxes[jn].y0)
    }
    cutImg := cropImg(subImg)
    if isEmptyImg(cutImg) {
      cutImg = createEmptyImg()
    }
    subFileName := path.Join(workDir, fmt.Sprintf("l-%03d.png", i))
    if fo, err := os.Create(subFileName); err != nil {
      log.Println(err, subFileName)
    } else {
      defer fo.Close()
      if err := png.Encode(fo, cutImg); err != nil {
        log.Println(err)
      }
    }
    i++
  }
  for _, box := range lineBboxes {
    if box.isEmpty() { continue }
    drawH(mm, box.x0+xx0, box.x1+xx0, yy1-box.y1)
    drawH(mm, box.x0+xx0, box.x1+xx0, yy1-box.y0)
    drawV(mm, box.x0+xx0, yy1-box.y1, yy1-box.y0)
    drawV(mm, box.x1+xx0, yy1-box.y1, yy1-box.y0)
  }
  previewImgName := workDir+"-preview.png"
  if fo, err := os.Create(previewImgName); err != nil {
    log.Println(err, previewImgName)
  } else {
    defer fo.Close()
    if err := png.Encode(fo, mm); err != nil {
      log.Println(err)
    }
  }
}

func imgWhiteLine(img *image.Gray, y int) bool {
  white := color.Gray{255}
  bounds := img.Bounds()
  for x := bounds.Min.X; x < bounds.Max.X; x++ {
    if img.At(x, y) != white {
      //log.Println("not white", y, x, img.At(x, y))
      return false
    }
  }
  return true
}

func isEmptyImg(img image.Image) bool {
  bb := img.Bounds()
  return bb.Max.X <= bb.Min.X || bb.Max.Y <= bb.Min.Y
}

func createEmptyImg() image.Image {
  img := image.NewGray(image.Rect(0, 0, 1, 1))
  img.Set(0, 0, color.Gray{255})
  return img
}

func cropImg(img *image.Gray) image.Image {
  // TODO: remove white border
  bounds := img.Bounds()
  //log.Println("cropImg bounds", bounds)
  yMin := bounds.Min.Y
  for yMin < bounds.Max.Y && imgWhiteLine(img, yMin) {
    yMin++
  }
  yMax := bounds.Max.Y
  for yMax > bounds.Min.Y && imgWhiteLine(img, yMax-1) {
    yMax--
  }
  if yMax > yMin {
    bounds.Min.Y = yMin
    bounds.Max.Y = yMax
  }
  //log.Println("cropped", bounds.Min.Y, bounds.Max.Y)
  crop := img.SubImage(bounds)
  return crop
}

func splitImageCutline(workDir string, lineBoxes []BoxLine,
    m image.Image) {
  nonEmptyLines := removeEmptyBoxLines(lineBoxes)
  log.Println("cut nonempty boxes", nonEmptyLines)
  cutLines := getCutLines(nonEmptyLines)
  xx0 := m.Bounds().Min.X
  yy1 := m.Bounds().Max.Y
  mm := m.(*image.Gray)
  white := color.Gray{255}
  // debug
  //drawCutLines(mm, xx0, yy1, cutLines)
  for i, line := range nonEmptyLines {
    lineBbox := line.boxes.boundingBox()
    y1 := lineBbox.y1 // upper border
    y0 := lineBbox.y0 // lower border
    h := y1 - y0 // height
    y1max := y1 + (LINE_BORDER * h)/100
    y0min := y0 - (LINE_BORDER * h)/100
    //log.Println(boxes2text(line.boxes))
    //log.Printf("line y0: %d y1: %d h: %d, y0min: %d y1max: %d\n",
    //  y0, y1, h, y0min, y1max)
    if i > 0 {
      bbcl := cutLines[i-1].boundingBox()
      y1 = bbcl.y1
    }
    if i < len(cutLines) {
      bbcl := cutLines[i].boundingBox()
      y0 = bbcl.y0
    }
    // restrict line height
    if y1 > y1max {
      y1 = y1max
    }
    if y0 < y0min {
      y0 = y0min
    }
    //log.Printf("Line %d, size %d %d %d %d (%s)\n", i, lineBbox.x0, y0,
    //  lineBbox.x1, y1, boxes2text(line.boxes))
    subImg := image.NewGray(image.Rect(
      0, 0, lineBbox.x1-lineBbox.x0, y1-y0),
    )
    draw.Draw(subImg, subImg.Bounds(), mm, image.Point{lineBbox.x0+xx0, yy1-y1},
      draw.Src)
    bx0 := lineBbox.x0+xx0
    by0 := y0
    by1 := y1
    if i > 0 {
      for k := 0; k < len(cutLines[i-1]); k += 2 {
        // upper border
        p0 := cutLines[i-1][k]
        p1 := cutLines[i-1][k+1]
        //log.Println("gray", p0, p1, bx0, by1)
        draw.Draw(subImg,
          image.Rect(p0.x-bx0, by1-p0.y, p1.x-bx0, 0),
          &image.Uniform{white}, image.Point{0,0}, draw.Src)
      }
    }
    if i < len(cutLines) {
      for k := 0; k < len(cutLines[i]); k += 2 {
        // lower border
        p0 := cutLines[i][k]
        p1 := cutLines[i][k+1]
        //log.Println("gray", p0, p1, bx0, by1)
        draw.Draw(subImg,
          image.Rect(p0.x-bx0, by1-p0.y, p1.x-bx0, by1-by0),
          &image.Uniform{white}, image.Point{0,0}, draw.Src)
      }
    }
    log.Println("before cropImg", subImg.Bounds())
    cutImg := cropImg(subImg)
    if isEmptyImg(cutImg) {
      cutImg = createEmptyImg()
    }
    log.Println("after cropImg", subImg.Bounds())
    subFileName := path.Join(workDir, fmt.Sprintf("l-%03d.png", i))
    if fo, err := os.Create(subFileName); err != nil {
      log.Println(err, subFileName)
    } else {
      defer fo.Close()
      if err := png.Encode(fo, cutImg); err != nil {
        log.Println(err)
      }
    }
  }
  drawCutLines(mm, xx0, yy1, cutLines)
  previewImgName := workDir+"-preview.png"
  if fo, err := os.Create(previewImgName); err != nil {
    log.Println(err, previewImgName)
  } else {
    defer fo.Close()
    if err := png.Encode(fo, mm); err != nil {
      log.Println(err)
    }
  }
}

func splitImage(workDir string, lineBoxes []BoxLine, lineBboxes []Box,
    m image.Image, isCutLines bool) {
  if isCutLines {
    splitImageCutline(workDir, lineBoxes, m)
  } else {
    splitImageBboxes(workDir, lineBoxes, lineBboxes, m)
  }
}

func handleFile(base string, img string, isCutLines bool) {
  inFile := base+".txt"
  boxFile := base+".box"
  lineBoxFile := base+"-lines.json"
  paraFile := base+"-paragraphs.json"
  fi, err := os.Open(img)
  if err != nil {
    log.Fatal(err)
  }
  defer fi.Close()
  reader, err := os.Open(img)
  if err != nil {
    log.Fatal(err)
  }
  m, _, err := image.Decode(reader)
  if err != nil {
    log.Fatal(err, img)
  }
  lines, boxes := readBoxes(inFile, boxFile)
  lineboxes := processBoxes(lines, boxes)
  lineBboxes := boundingBoxes(lineboxes)
  log.Println("lineboxes", lineBboxes)
  err = os.MkdirAll(base, os.ModePerm)
  if err != nil {
    log.Fatal(err)
  }
  writeJson(lineBoxFile, paraFile, lineBboxes, m)
  splitImage(base, lineboxes, lineBboxes, m, isCutLines)
  splitText(base, lineBboxes)
}

func main() {
  params := readParams()
  handleFile(params.BaseFileName, params.ImgFileName, params.CutLines)
}
