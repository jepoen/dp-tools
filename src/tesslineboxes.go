package main

/* Build line boxes from text prediction and box files generated by
 * tesseract
 * Config file:
 *   tessedit_create_txt 1 
 *   tessedit_create_boxfile 1
 *
 * Input: img.png predict.box predict.txt
 * Output: predict-preview.png
 *         predict-lines.json
 *         predict-paragraphs.json
 *         predict/t-###.txt
 *         predict/l-###.png
 */

import (
  "bufio"
  "encoding/json"
  "errors"
  "flag"
  "fmt"
  _ "io/ioutil"
  "image"
  "image/color"
  "image/draw"
  "image/png"
  "log"
  "os"
  "path"
  _ "regexp"
  "sort"
  "strconv"
  "strings"
  "unicode"
  _ "unicode/utf8"
)

type Params struct {
  ImgFileName string
  BaseFileName string
}

type Quartiles struct {
  min int
  q1  int
  med int
  q3  int
  max int
}

type Box struct {
  glyph string
  x0 int
  y0 int
  x1 int
  y1 int
}

type BoxLine struct {
  boxes []Box
}

type JsBoxes struct {
  Boxes [][]int
}

type JsParas struct {
  Paragraphs []bool
}

type stringlist_t []string
type wordcount_t struct {
  word string
  count int
}

type summary_t struct {
  replacements map[string]wordcount_t
}

var summary summary_t

const (
  FONT_NONE = iota
  FONT_ANTIQUA
  FONT_FRAKTUR
)

const (
  OPT_FONT = iota
  OPT_JOIN
  OPT_RAW
  OPT_RENUMBER
  OPT_REPLACE_SF
)

func init() {
}

func str2map(s string) map[rune]bool {
  res := map[rune]bool{}
  for _, r := range(s) {
    res[r] = true
  }
  return res
}

func (q Quartiles) String() string {
  return fmt.Sprintf("min: %d q1: %d med: %d q3: %d max: %d",
    q.min, q.q1, q.med, q.q3, q.max)
}

const UsageText = `Split png image into lines according to text and box tessact prediction
Usage: %s options

Output: <base>-preview.png
        <base>-lines.json         line boxes
        <base>-paragraphs.json    paragraphs
        <base>/l-###.png          line images
`
func readParams() *Params {
  flag.Usage = func() {
    fmt.Fprintf(os.Stderr, UsageText, os.Args[0])
    flag.PrintDefaults()
  }
  params := &Params{}
  flag.StringVar(&params.ImgFileName, "image", "",
    "Image file name")
  flag.StringVar(&params.ImgFileName, "i", "",
    "Image file name (short)")
  flag.StringVar(&params.BaseFileName, "basename", "",
    "Base file name of text and box file")
  flag.StringVar(&params.BaseFileName, "b", "",
    "Base file name of text and box file (short)")
  flag.Parse()
  if params.ImgFileName == "" {
    flag.Usage()
    log.Fatal("Image file missing")
  }
  if params.BaseFileName == "" {
    flag.Usage()
    log.Fatal("Base file name missing")
  }
  return params
}

func (box *Box) isEmpty() bool {
  return box.y1-box.y0 == 0
}

func nonEmptyBoxes(boxes []Box) []Box {
  res := []Box{}
  for _, b := range boxes {
    if !b.isEmpty() {
      res = append(res, b)
    }
  }
  return res;
}

func (box *Box) wGlyph() int {
  if box.x0 < 0 { return -1 }
  return box.x1 - box.x0
}

func (box *Box) hGlyph() int {
  if box.y0 < 0 { return -1 }
  return box.y1 - box.y0
}

func intQuartiles (vals []int) Quartiles {
  if len(vals) == 0 {
    return Quartiles{-1, -1, -1, -1, -1}
  }
  sort.Ints(vals)
  l := len(vals)-1
  return Quartiles{vals[0], vals[l/4], vals[l/2], vals[3*l/4], vals[l]}
}

func boundingBox(boxes []Box) Box {
  if len(boxes) == 0 {
    return Box{"", 0, 0, 0, 0}
  }
  res := boxes[0]
  for _, b := range boxes {
    if b.isEmpty() { continue }
    if b.x0 < res.x0 { res.x0 = b.x0 }
    if b.y0 < res.y0 { res.y0 = b.y0 }
    if b.x1 > res.x1 { res.x1 = b.x1 }
    if b.y1 > res.y1 { res.y1 = b.y1 }
    res.glyph += b.glyph
  }
  return res
}

func readBoxes(txtFile, boxFile string) ([]string, []Box) {
  ftxt, err2 := os.Open(txtFile)
  txt := []string{}
  if err2 != nil {
    log.Println(err2)
    return txt, nil
  }
  defer ftxt.Close()
  txtScanner := bufio.NewScanner(ftxt)
  for txtScanner.Scan() {
    txt = append(txt, txtScanner.Text())
  }
  if _, err := os.Stat(boxFile); os.IsNotExist(err) {
    log.Println("No box file", boxFile)
    return txt, nil
  }
  fbox, err := os.Open(boxFile)
  if err != nil {
    fmt.Println(err)
    return txt, nil
  }
  defer fbox.Close()
  boxScanner := bufio.NewScanner(fbox)
  boxes := []Box{}
  for boxScanner.Scan() {
    parts := strings.Split(boxScanner.Text(), " ")
    glyph := parts[0]
    pos := make([]int, 4)
    for i, p := range(parts[1:5]) {
      pos[i], err = strconv.Atoi(p)
    }
    boxes = append(boxes, Box{glyph, pos[0], pos[1], pos[2], pos[3]})
  }
  return txt, boxes
}

func matchBoxes(boxes []Box, lines []string) []Box {
  res := []Box{}
  part := strings.Join(lines, "\n")
  for _, box := range(boxes) {
    i := strings.Index(part, box.glyph)
    if i < 0 {
      log.Printf("Glyph %s not in string\n", box.glyph)
      continue
    } else if i > 0 {
      for _, r := range(part[:i]) {
        res = append(res, Box{string(r), 0, 0, 0, 0})
      }
      if part[:i] != " " {
        log.Printf("No Box for %q\n", part[:i])
      }
    }
    res = append(res, box)
    part = part[i+len(box.glyph):]
  }
  if part != "" {
    for _, r := range(part) {
      res = append(res, Box{string(r), -1, -1, -1, -1})
    }
    log.Printf("No Box for %q\n", part)
  }
  return res
}

func boxes2text(boxes []Box) string {
  res := []string{}
  for _, box := range(boxes) {
    res = append(res, box.glyph)
  }
  return strings.Join(res, "")
}

func newBoxLine(boxes []Box) BoxLine {
  res := BoxLine{
    boxes: boxes,
  }
  return res
}

func boxes2lines(boxes []Box) []BoxLine {
  res := []BoxLine{}
  startIdx := 0
  for i, box := range(boxes) {
    if box.glyph == "\n" {
      res = append(res, newBoxLine(boxes[startIdx:i]))
      startIdx = i+1
    }
  }
  if startIdx < len(boxes)-1 {
    res = append(res, newBoxLine(boxes[startIdx:]))
  }
  for _, boxes := range(res) {
    log.Println(boxes2text(boxes.boxes))
  }
  return res
}

func medStartPos(boxLines []BoxLine) (Quartiles, error) {
  starts := []int{}
  for _, boxLine := range(boxLines) {
    x0 := -1
    for _, box := range(boxLine.boxes) {
      if box.x0 >= 0 {
        x0 = box.x0
        break
      }
    }
    if x0 >= 0 {
      starts = append(starts, x0)
    }
    //log.Printf("%d %q\n", x0, boxes2text(boxLine.boxes))
  }
  if len(starts) == 0 {
    return Quartiles{-1, -1, -1, -1, -1}, errors.New("empty")
  }
  return intQuartiles(starts), nil
}

func processBoxes(lines []string, boxes []Box) []BoxLine {
  boxes = matchBoxes(boxes, lines)
  text := strings.Join(lines, "\n")
  boxText := boxes2text(boxes)
  log.Println("isEqual: ", text==boxText)
  return boxes2lines(boxes)
}

func boundingBoxes(boxLines []BoxLine) []Box {
  res := []Box{}
  for _, boxLine := range(boxLines) {
    bbox := boundingBox(boxLine.boxes)
    res = append(res, bbox)
  }
  return res
}

func NewSummary() summary_t {
  var summary summary_t
  summary.replacements = make(map[string]wordcount_t)
  return summary
}

func LogAddReplacement(word string, newWord string) {
  e, ok := summary.replacements[word]
  if ok {
    if e.word != newWord {
      fmt.Println("Irregular replacement", word, e.word, newWord)
    }
    e.count++
  } else {
    e.word = newWord
    e.count = 1
  }
  summary.replacements[word] = e
}

func containsRune(runes [] rune, r rune) bool {
  for _, rr := range runes {
    if rr == r { return true; }
  }
  return false;
}

func joinLines(text stringlist_t) stringlist_t {
  caps := make([]rune, 0, 29)
  for r := 'A'; r <= 'Z'; r++ { caps = append(caps, r) }
  caps = append(caps, 'Ä', 'Ö', 'Ü')
  // join char is ASCII = 1 byte
  for i := 0; i < len(text)-1; i++ {
    line := text[i]
    pLast := len(line)-1
    if pLast < 1 { continue }
    if line[pLast] != '-' || line[pLast-1] == '-' { continue }
    nline := text[i+1]
    if len(strings.Trim(nline, " \t")) == 0 { continue }
    pos := -1
    var first rune
    for i, r := range nline {
      if i == 0 { first = r }
      if r == ' ' {
        pos = i
	break
      }
    }
    //fmt.Println("before:", line, "||", nline)
    // don't remove dash if following line starts with cap
    noRemove := 0
    if containsRune(caps, first) { noRemove = 1 }
    if pos > 0 {
      text[i] = line[0:pLast+noRemove]+nline[0:pos]
      text[i+1] = nline[pos+1:]
    } else {
      text[i] = line[0:pLast+noRemove]+nline
      text[i+1] = ""
    }
    //fmt.Println("after:", text[i], "||", text[i+1])
  }
  return text
}

/**
 * Remove repeated blank lines
 */
func removeBlankLines(text stringlist_t) stringlist_t {
  ntext := make([]string, 0, len(text))
  prevBlank := false
  for _, line := range text {
    line = strings.Trim(line, " \t")
    if line == "" {
      if prevBlank { continue }
      prevBlank = true
    } else {
      prevBlank = false
    }
    ntext = append(ntext, line)
  }
  return ntext
}

/**
 * splits line into wordsep, word, and remaining line
 */
func nextWord(line string) (string, string, string) {
  sep := ""
  word := ""
  rest := ""
  state := 0
  wordStart := -1
  wordEnd := -1
  for i, r := range line {
    if unicode.IsLetter(r) && state == 0 {
      wordStart = i
      sep = line[0:wordStart]
      state = 1
    } else if !unicode.IsLetter(r) && state == 1 {
      wordEnd = i
      word = line[wordStart:wordEnd]
      rest = line[wordEnd:]
      state = 2
    }
  }
  if state == 0 {
    return line, "", ""
  } else if state == 1 {
    word = line[wordStart:]
    return sep, word, ""
  } else {
    return sep, word, rest
  }
}

func buildJson(boxes []Box, imgBounds image.Rectangle) (JsBoxes, JsParas) {
  var resBoxes JsBoxes
  var resParas JsParas

  xx0 := imgBounds.Min.X
  yy1 := imgBounds.Max.Y
  isPara := false
  for _, box := range boxes {
    //fmt.Printf("x0: %d xx0: %d\n", box.x0, xx0)
    if box.isEmpty() {
      isPara = true
    } else {
      line := []int{box.x0-xx0, yy1-box.y1, box.x1-xx0, yy1-box.y0}
      resBoxes.Boxes = append(resBoxes.Boxes, line)
      resParas.Paragraphs = append(resParas.Paragraphs, isPara)
      isPara = false
    }
  }
  return resBoxes, resParas
}

func writeJson(lineBoxFile, paraFile string, lineboxes []Box, m image.Image) {
  jsBoxes, jsParas := buildJson(lineboxes, m.Bounds())
  if b, err := json.Marshal(jsBoxes); err != nil {
    log.Fatal(err)
  } else {
    fo, err := os.Create(lineBoxFile)
    if err != nil {
      log.Fatal(err)
    }
    fo.Write(b)
    fo.Close()
  }
  if b, err := json.Marshal(jsParas); err != nil {
    log.Fatal(err)
  } else {
    fo, err := os.Create(paraFile)
    if err != nil {
      log.Fatal(err)
    }
    fo.Write(b)
    fo.Close()
  }
}

func splitText(base string, lineboxes []Box) {
  i := 0
  for _, box := range lineboxes {
    if box.isEmpty() { continue }
    fileName := path.Join(base, fmt.Sprintf("t-%03d.txt", i))
    if fo, err := os.Create(fileName); err != nil {
      log.Println(err, fileName)
    } else {
      fo.WriteString(box.glyph)
      fo.Close()
    }
    i++
  }
}

func drawH(mm *image.Gray, x0, x1, y int) {
  for x := x0; x <= x1; x++ {
    mm.SetGray(x, y, color.Gray{0})
  }
}

func drawV(mm *image.Gray, x, y0, y1 int) {
  for y := y0; y <= y1; y++ {
    mm.SetGray(x, y, color.Gray{0})
  }
}

func splitImage(workDir string, lineBoxes []BoxLine, lineBboxes []Box,
    m image.Image) {
  xx0 := m.Bounds().Min.X
  yy1 := m.Bounds().Max.Y
  mm := m.(*image.Gray)
  white := color.Gray{255}
  i := 0
  for j, box := range lineBboxes {
    if box.isEmpty() { continue }
    subImg := image.NewGray(image.Rect(
      0, 0, box.x1-box.x0, box.y1-box.y0),
    )
    draw.Draw(subImg, subImg.Bounds(), mm, image.Point{box.x0+xx0, yy1-box.y1},
      draw.Src)
    fullBoxes := nonEmptyBoxes(lineBoxes[j].boxes)
    for k, b := range fullBoxes {
      x0 := b.x0-box.x0
      if k > 0 {
        x0 = fullBoxes[k-1].x1 - box.x0 + 1
      }
      x1 := b.x1 - box.x0
      if k < len(fullBoxes) -1 {
        x1 = fullBoxes[k+1].x0 -box.x0 - 1
      }
      y0 := 0
      y1 := box.y1 - b.y1 - 1
      draw.Draw(subImg,
        image.Rect(x0, y0, x1, y1),
        &image.Uniform{white}, image.Point{0,0}, draw.Src)
      y0 = box.y1 - b.y0 + 1
      y1 = box.y1 - box.y0
      draw.Draw(subImg,
        image.Rectangle{image.Point{x0, y0}, image.Point{x1, y1}},
        &image.Uniform{white}, image.ZP, draw.Src)
    }
    subFileName := path.Join(workDir, fmt.Sprintf("l-%03d.png", i))
    if fo, err := os.Create(subFileName); err != nil {
      log.Println(err, subFileName)
    } else {
      defer fo.Close()
      if err := png.Encode(fo, subImg); err != nil {
        log.Println(err)
      }
    }
    i++
  }
  for j, box := range lineBboxes {
    if box.isEmpty() { continue }
    drawH(mm, box.x0+xx0, box.x1+xx0, yy1-box.y1)
    drawH(mm, box.x0+xx0, box.x1+xx0, yy1-box.y0)
    drawV(mm, box.x0+xx0, yy1-box.y1, yy1-box.y0)
    drawV(mm, box.x1+xx0, yy1-box.y1, yy1-box.y0)
    fullBoxes := nonEmptyBoxes(lineBoxes[j].boxes)
    for k, b := range fullBoxes {
      x0 := b.x0
      y0 := b.y0
      if k > 0 {
        if fullBoxes[k-1].y0 <= b.y0 {
          x0 = fullBoxes[k-1].x1
        }
        y0 = fullBoxes[k-1].y0
      }
      x1 := b.x1
      y1 := b.y0
      if k < len(fullBoxes)-1 {
        if fullBoxes[k+1].y0 <= b.y0 {
          x1 = fullBoxes[k+1].x0
        }
        y1 = fullBoxes[k+1].y0
      }
      drawH(mm, x0+xx0, x1+xx0, yy1-b.y0)
      drawV(mm, x0+xx0, yy1-b.y0, yy1-y0)
      drawV(mm, x1+xx0, yy1-b.y0, yy1-y1)
      x0 = b.x0
      y0 = b.y1
      if k > 0 {
        if fullBoxes[k-1].y1 >= b.y1 {
          x0 = fullBoxes[k-1].x1
        }
        y0 = fullBoxes[k-1].y1
      }
      x1 = b.x1
      y1 = b.y1
      if k < len(fullBoxes)-1 {
        if fullBoxes[k+1].y1 >= b.y1 {
          x1 = fullBoxes[k+1].x0
        }
        y1 = fullBoxes[k+1].y1
      }
      drawH(mm, x0+xx0, x1+xx0, yy1-b.y1)
      drawV(mm, x0+xx0, yy1-b.y1, yy1-y0)
      drawV(mm, x1+xx0, yy1-b.y1, yy1-y1)
    }
  }
  previewImgName := workDir+"-preview.png"
  if fo, err := os.Create(previewImgName); err != nil {
    log.Println(err, previewImgName)
  } else {
    defer fo.Close()
    if err := png.Encode(fo, mm); err != nil {
      log.Println(err)
    }
  }
}

func handleFile(base string, img string) {
  inFile := base+".txt"
  boxFile := base+".box"
  lineBoxFile := base+"-lines.json"
  paraFile := base+"-paragraphs.json"
  fi, err := os.Open(img)
  if err != nil {
    log.Fatal(err)
  }
  defer fi.Close()
  reader, err := os.Open(img)
  if err != nil {
    log.Fatal(err)
  }
  m, _, err := image.Decode(reader)
  if err != nil {
    log.Fatal(err, img)
  }
  lines, boxes := readBoxes(inFile, boxFile)
  lineboxes := processBoxes(lines, boxes)
  lineBboxes := boundingBoxes(lineboxes)
  log.Println("lineboxes", lineBboxes)
  err = os.MkdirAll(base, os.ModePerm)
  if err != nil {
    log.Fatal(err)
  }
  writeJson(lineBoxFile, paraFile, lineBboxes, m)
  splitImage(base, lineboxes, lineBboxes, m)
  splitText(base, lineBboxes)
}

func main() {
  params := readParams()
  handleFile(params.BaseFileName, params.ImgFileName)
}
